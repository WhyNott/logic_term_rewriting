# Instalation
The compiler should be able to function on any supported .NET core platform (including Windows, Linux and Mac OS), but some dependencies will need to be installed first. 

## Obtain and install .NET core 5.0
For installation instructions for your platform, see https://docs.microsoft.com/en-us/dotnet/core/install/ . 
(Make sure that the installed runtime is version 5.0, as earlier or later version will not work properly!)

## Install dotnet-script
After the .NET CLI is installed, the `dotnet-script` tool (used to run the C# script files output by the compiler) can be installed directly on any platform by running the following:

`dotnet tool install -g dotnet-script`

## Build the runtime library
The scripts generated by the compiler require the language runtime code contained within the `Runtime` module of the project. This code will need to be built as a DLL file and __placed in the same directory as the compiled script__ you want to run.

The runtime library can be compiled by running the following within the main directory of the project:

`dotnet publish ./Runtime/Runtime.csproj --framework net5.0  --output .`

This should now result in a new file named Runtime.dll being created in the main directory of the project, which can be copied to wherever the script should be run. 

# Compiler and CLI usage

## Compiling files
To compile a file from the clause-based logic form to a C# script, the following command should be run in the main project directory:
`dotnet run --project CLI -- [input-file] [output-file]`

For example, to run the `family.yaml` program from the `examples` folder into an `output.csx` C# script, one can run the following:
`dotnet run --project CLI -- examples/family.yaml output.csx`

The `examples` folder contains several files that can be used to test the program, with examples of usage in a section at the end of this file.

## Toplevel REPL usage
The compiled script file can be run with `dotnet-script` through the following command:

`dotnet-script [name of the output file]`, i.e. `dotnet-script output.csx`

Note that while the script does not need to be in the same directory as the project, there needs to be a Runtime.dll file in the same directory as the script for it to function. See the instalation instruction for how to compile it from the project code.

After the script is run, the user will be presented with the toplevel REPL which allows making queries against the compiled logic program. The syntax for the query is simplified, allowing to call a single predicate (deliniated with angle brackets) filled with either variables or structured terms (which must also be deliniated with angle brackets). The system will then attempt to resolve that query, and if any answers are possible it will return `yes`. If the query contains unbound variables, it will present the bindings allowing for that query to resolve (assuming any exist). If there are no solutions, the system will return `no`.

After returning the first answer, the CLI will enter an "answer mode" (indicated by `answers>` as the prompt). Pressing enter will return the next possible set of binding (if any exists). Inputing "a" will return all possible answers (which might result in a crash or hang if the predicate has an infinite number of solutions). As in the normal prompt, "quit" will quit the program.

## Example interactions

### `examples/family.yaml`

```
query> <?X is the father of <Abraham>>
yes
?X: <Terach>
answers> 
no
query> <<John> is the father of <Abraham>>
no
query> <<Abraham> is son of <Terach>>
yes
answers> 
no
query> <?X is daughter of ?Y>
yes
?X: <Milcah>
?Y: <Haran>
answers> 
yes
?X: <Yiscah>
?Y: <Haran>
answers> 
no
query> <?X is daughter of <Haran>>
yes
?X: <Milcah>
answers> 
yes
?X: <Yiscah>
answers> 
no
```

### `examples/logical_and_gate.yaml`

```
query> <?In1 and ?In2 is ?Out>
yes
?In1: <n3>
?In2: <n5>
?Out: <n1>
answers> 
no
query> <?In1 nand ?In2 is ?Out>
yes
?In1: <n3>
?In2: <n5>
?Out: <n2>
answers> 
no

```


### `examples/peano.yaml`

Example of a query with an infinite number of results:
```
query> <?X is a natural number>
yes
?X: <0>
answers> 
yes
?X: <s of <0>>
answers> 
yes
?X: <s of <s of <0>>>
answers> 
yes
?X: <s of <s of <s of <0>>>>
answers> 
yes
?X: <s of <s of <s of <s of <0>>>>>
answers> 
yes
?X: <s of <s of <s of <s of <s of <0>>>>>>
answers> quit
```
